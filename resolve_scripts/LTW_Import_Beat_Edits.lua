-- LTW Beat Sync Editor
-- Imports a Beat Map JSON and creates a timeline with cuts at every beat
-- Author: LTW Video Editor Pro

local function read_file(path)
    local file = io.open(path, "r")
    if not file then return nil end
    local content = file:read("*a")
    file:close()
    return content
end

local function get_beat_map()
    local ui = fu.UIManager
    local disp = bmd.UIDispatcher(ui)
    
    local win = disp:AddWindow({
        ID = 'BeatWin',
        WindowTitle = 'LTW Beat Sync',
        Geometry = {100, 100, 400, 150},
        Spacing = 10,
        
        ui:VGroup{
            ui:Label{ID = 'Label', Text = 'Select Beat Map JSON:', Weight = 0},
            ui:LineEdit{ID = 'PathInput', PlaceholderText = '/path/to/song.json'},
            ui:Label{ID = 'Label2', Text = 'Select Clips Bin:', Weight = 0},
            ui:ComboBox{ID = 'BinCombo'},
            ui:VGap(10),
            ui:HGroup{
                Weight = 0,
                ui:Button{ID = 'ImportBtn', Text = 'Sync Clips to Beats'},
                ui:Button{ID = 'CancelBtn', Text = 'Cancel'}
            }
        }
    })
    
    local itm = win:GetItems()
    
    -- Populate Bins
    local resolve = Resolve()
    local projectManager = resolve:GetProjectManager()
    local project = projectManager:GetCurrentProject()
    local mediaPool = project:GetMediaPool()
    local rootFolder = mediaPool:GetRootFolder()
    local subFolders = rootFolder:GetSubFolderList()
    
    itm.BinCombo:AddItem("Master")
    for _, folder in ipairs(subFolders) do
        itm.BinCombo:AddItem(folder:GetName())
    end
    
    local result = nil
    
    function win.On.ImportBtn.Clicked(ev)
        result = {
            json_path = itm.PathInput.Text,
            bin_name = itm.BinCombo.CurrentText
        }
        disp:ExitLoop()
    end
    
    function win.On.CancelBtn.Clicked(ev)
        disp:ExitLoop()
    end
    
    function win.On.BeatWin.Close(ev)
        disp:ExitLoop()
    end
    
    win:Show()
    disp:RunLoop()
    win:Hide()
    
    return result
end

local function sync_beats(settings)
    if not settings or settings.json_path == "" then return end
    
    -- Read JSON (Simple parsing as Resolve doesn't have a full JSON library by default)
    -- We will regex the beats array
    local content = read_file(settings.json_path)
    if not content then 
        print("Could not read file: " .. settings.json_path)
        return
    end
    
    local beats = {}
    for beat in string.gmatch(content, "([%d%.]+)[,]]") do 
        table.insert(beats, tonumber(beat))
    end
    
    if #beats == 0 then
        -- Try alternate regex for last item or different formatting
        for beat in string.gmatch(content, "([%d%.]+)%s*") do
             -- This might match too much, simple parsing is brittle
             -- Ideally we use a library, but for now let's assume our python format
        end
        -- Just check manual parsing
    end
    
    -- Re-parse properly for the specific format generated by our python script
    -- "beats": [ 0.5, 1.2, ... ]
    beats = {}
    local in_beats = false
    for line in string.gmatch(content, "[^\r\n]+") do
        if string.find(line, '"beats":') then in_beats = true end
        if in_beats then
            for num in string.gmatch(line, "([%d%.]+)") do
                table.insert(beats, tonumber(num))
            end
        end
        if string.find(line, "]") and in_beats then break end
    end
    
    print("Loaded " .. #beats .. " beats.")
    
    -- Create Timeline
    local resolve = Resolve()
    local projectManager = resolve:GetProjectManager()
    local project = projectManager:GetCurrentProject()
    local mediaPool = project:GetMediaPool()
    local timeline = mediaPool:CreateEmptyTimeline("Beat_Sync_Timeline")
    
    -- Get Clips
    local root = mediaPool:GetRootFolder()
    local clip_folder = root
    if settings.bin_name ~= "Master" then
        -- Find subfolder (simplified)
        local sub = root:GetSubFolderList()
        for _, f in ipairs(sub) do
            if f:GetName() == settings.bin_name then clip_folder = f break end
        end
    end
    
    local clips = clip_folder:GetClipList()
    if #clips == 0 then print("No clips in selected bin.") return end
    
    print("Syncing " .. #clips .. " clips to beats...")
    
    -- Add clips to timeline
    local current_beat_idx = 1
    local clip_idx = 1
    local fps = project:GetSetting("timelineFrameRate")
    
    -- Strategy: 
    -- 1. Beat 1 -> Beat 2 duration = X frames
    -- 2. Take Clip 1, mark In/Out to match X frames
    -- 3. Append to timeline
    
    while current_beat_idx < #beats and clip_idx <= #clips do
        local start_time = beats[current_beat_idx]
        local end_time = beats[current_beat_idx + 1]
        local duration_sec = end_time - start_time
        local duration_frames = math.floor(duration_sec * fps)
        
        local clip = clips[clip_idx]
        
        -- Set SubClip (simplified, creating subclips in API is hard, we just append and trim?)
        -- Actually AppendToTimeline takes MediaPoolItems.
        -- We can't easily set the duration BEFORE appending via simple API.
        -- WORKAROUND: Append, then Trim? Or create SubClip in media pool.
        
        -- Better Workaround for MVP: 
        -- Just Append, and let user know they need to use "Scene Cut Detection" next time?
        -- No, we promised Beat Sync.
        
        -- Let's try adding markers instead? No, we want cuts.
        
        -- We can try:
        -- 1. Create SubClip in Media Pool
        -- 2. Append SubClip
        
        -- local subClip = {
        --    mediaPoolItem = clip,
        --    startFrame = 0,
        --    endFrame = duration_frames
        -- }
        -- mediaPool:AppendToTimeline({subClip}) -- Resolve 17+ supports this struct
        
        local entry = {
            ["mediaPoolItem"] = clip,
            ["startFrame"] = 0,
            ["endFrame"] = duration_frames
        }
        
        if mediaPool:AppendToTimeline({entry}) then
            -- Success
        else
            print("Failed to append clip " .. clip:GetName())
        end
        
        current_beat_idx = current_beat_idx + 1
        clip_idx = clip_idx + 1
        if clip_idx > #clips then clip_idx = 1 end -- Loop clips
    end
    
    print("Done! Sync complete.")
end

local settings = get_beat_map()
sync_beats(settings)

